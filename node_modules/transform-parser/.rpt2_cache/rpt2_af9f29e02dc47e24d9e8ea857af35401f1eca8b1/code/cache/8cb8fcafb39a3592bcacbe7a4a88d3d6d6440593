{"code":"// List of transforms for which the value has to be numeral. Default px substitution for these\r\n// transforms will be skipped.\r\nconst transformsWithNumeralValues = ['scale', 'scale3d', 'scaleX', 'scaleY', 'scaleZ'];\r\n/**\r\n * Returns a object representation of the transform string supplied. It parses the string and\r\n * converts them to an object.\r\n * @param transformString String containing the transforms\r\n */\r\nconst parse = (transformString) => {\r\n    const transforms = transformString.trim().split(/\\) |\\)/);\r\n    // Handle \"initial\", \"inherit\", \"unset\".\r\n    if (transforms.length === 1) {\r\n        return {\r\n            [transforms[0]]: true,\r\n        };\r\n    }\r\n    /**\r\n     * Converts string values to number when the unit is pixel or parsable. Returns a string when the\r\n     * unit is not pixel or not parsable.\r\n     * @param value Value of a transform\r\n     */\r\n    const parsePixelValues = (value) => {\r\n        if (value.endsWith('px'))\r\n            return parseFloat(value);\r\n        if (!Number.isNaN(Number(value)))\r\n            return Number(value);\r\n        return value;\r\n    };\r\n    return transforms.reduce((acc, transform) => {\r\n        if (!transform)\r\n            return acc;\r\n        const [name, transformValue] = transform.split('(');\r\n        const valueArray = transformValue.split(',');\r\n        const values = valueArray.map((val) => {\r\n            return parsePixelValues(val.endsWith(')') ? val.replace(')', '') : val.trim());\r\n        });\r\n        const value = values.length === 1 ? values[0] : values;\r\n        return {\r\n            ...acc, ...{ [name]: value },\r\n        };\r\n    }, {});\r\n};\r\n/**\r\n * Returns the transform string constructed from the transform object supplied.\r\n * @param transformObject Object containing the transforms\r\n */\r\nconst stringify = (transformObject) => {\r\n    const resolveUnits = (key, val) => {\r\n        if (typeof val === 'number' && !transformsWithNumeralValues.includes(key)) {\r\n            return `${val}px`;\r\n        }\r\n        return val.toString();\r\n    };\r\n    return Object.keys(transformObject).reduce((acc, key) => {\r\n        const value = transformObject[key];\r\n        if (value === true)\r\n            return key;\r\n        if (value === false)\r\n            return acc;\r\n        if (Array.isArray(value)) {\r\n            return `${acc} ${key}(${value.map((val) => resolveUnits(key, val)).join(', ')})`;\r\n        }\r\n        return `${acc} ${key}(${resolveUnits(key, value)})`;\r\n    }, '')\r\n        .trim();\r\n};\r\nexport { parse, stringify };\r\n","references":[],"dts":{"name":"/Users/praneshr/Documents/GitHub/transform-parser/index.d.ts","writeByteOrderMark":false,"text":"export interface TransformObject {\r\n    [key: string]: number | string | (string | number)[] | boolean;\r\n}\r\n/**\r\n * Returns a object representation of the transform string supplied. It parses the string and\r\n * converts them to an object.\r\n * @param transformString String containing the transforms\r\n */\r\ndeclare const parse: (transformString: string) => TransformObject;\r\n/**\r\n * Returns the transform string constructed from the transform object supplied.\r\n * @param transformObject Object containing the transforms\r\n */\r\ndeclare const stringify: (transformObject: TransformObject) => string;\r\nexport { parse, stringify };\r\n"}}
